<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Carte Interactive des Randonn√©es</title>
    <link rel="icon" href="{{ url_for('static', filename='favicon.ico') }}">
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" />
    <link href="https://cesium.com/downloads/cesiumjs/releases/1.108/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
    <script src="https://cesium.com/downloads/cesiumjs/releases/1.108/Build/Cesium/Cesium.js"></script>
    
    <style>
        /* Nouveau conteneur pour la vue 3D */
        #cesiumContainer { 
            display: none; 
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            z-index: 9999; 
        }
        .cesium-controls { 
            position: absolute; 
            top: 20px; 
            right: 20px; 
            z-index: 10000; 
            display: flex; 
            gap: 10px; 
        }
        .btn-3d {
            padding: 10px 15px;
            background: #10b981;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
            color: #ccc;
            color: white;
            overflow: hidden;
        }

        .container {
            display: flex;
            height: 100vh;
            flex-direction: column;
        }

        /* Header */
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            z-index: 1000;
        }

        .header h1 {
            font-size: 1.5rem;
            font-weight: 600;
        }

        .header-buttons {
            display: flex;
            gap: 1rem;
        }

        .btn {
            padding: 0.6rem 1.2rem;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }

        .btn-primary {
            background: white;
            color: #667eea;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(255,255,255,0.3);
        }

        .btn-secondary {
            background: rgba(255,255,255,0.2);
            color: white;
            border: 1px solid rgba(255,255,255,0.3);
        }

        .btn-secondary:hover {
            background: rgba(255,255,255,0.3);
        }

        /* Main Content */
        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        /* Sidebar */
        .sidebar {
            width: 350px;
            background: #2a2a2a;
            overflow-y: auto;
            padding: 1.5rem;
            box-shadow: 2px 0 10px rgba(0,0,0,0.3);
        }

        .sidebar-section {
            background: #333;
            border-radius: 10px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
        }

        .sidebar-section h3 {
            margin-bottom: 1rem;
            font-size: 1.1rem;
            color: #667eea;
        }

        .filter-group {
            margin-bottom: 1rem;
        }

        .filter-group label {
            display: block;
            margin-bottom: 0.5rem;
            color: #aaa;
            font-size: 0.9rem;
        }

        .filter-group select {
            width: 100%;
            padding: 0.6rem;
            border-radius: 6px;
            border: 1px solid #444;
            background: #2a2a2a;
            color: white;
            cursor: pointer;
        }

        /* Hike List */
        .hike-item {
            background: #2a2a2a;
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
            cursor: pointer;
            transition: all 0.3s;
            border: 2px solid transparent;
        }

        .hike-item:hover {
            background: #3a3a3a;
            transform: translateX(5px);
        }

        .hike-item.active {
            border-color: #667eea;
            background: #3a3a3a;
        }

        .hike-header {
            display: flex;
            gap: 1rem;
            margin-bottom: 0.8rem;
        }

        .hike-image {
            width: 80px;
            height: 80px;
            border-radius: 6px;
            object-fit: cover;
        }

        .hike-info {
            flex: 1;
        }

        .hike-name {
            font-weight: 600;
            margin-bottom: 0.3rem;
            font-size: 1rem;
        }

        .hike-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.3rem;
            font-size: 0.85rem;
            color: #aaa;
        }

        /* Map Container */
        .map-container {
            flex: 1;
            position: relative;
        }

        #map {
            width: 100%;
            height: 100%;
        }

        /* Popup Customization */
        .leaflet-popup-content-wrapper {
            background: #2a2a2a;
            color: white;
            border-radius: 10px;
            padding: 0;
         }

        .leaflet-popup-content {
            margin: 0;
            min-width: 300px;
        }

        .leaflet-popup {
            z-index: 2000 !important;
         }

        .leaflet-popup-tip-container {
            z-index: 2000 !important;
            position: relative !important;
        }

        .leaflet-popup-pane {
            z-index: 2000 !important;
            position: absolute !important;
        }

        /* Forcer le popup √† s'ouvrir vers le haut */
        .leaflet-popup-top {
            margin-bottom: 0 !important;
        }

        .leaflet-popup-bottom {
            margin-top: 0 !important;
        }

        .popup-content {
            padding: 1rem;
        }

        .popup-image {
            width: 100%;
            height: 150px;
            object-fit: cover;
            border-radius: 10px 10px 0 0;
        }

        .popup-title {
            font-size: 1.2rem;
            font-weight: 600;
            margin: 1rem 0 0.5rem;
        }

        .popup-description {
            color: #aaa;
            font-size: 0.9rem;
            margin-bottom: 1rem;
        }

        .popup-stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.8rem;
            margin-bottom: 1rem;
        }

        .popup-stat {
            background: #333;
            padding: 0.6rem;
            border-radius: 6px;
            text-align: center;
        }

        .popup-stat-value {
            font-size: 1.2rem;
            font-weight: 600;
            color: #667eea;
        }

        .popup-stat-label {
            font-size: 0.75rem;
            color: #aaa;
            margin-top: 0.2rem;
        }

        .popup-button {
            width: 100%;
            padding: 0.8rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
        }

        .popup-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        /* Stats Banner */
        .stats-banner {
            position: absolute;
            top: 1rem;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(42, 42, 42, 0.95);
            backdrop-filter: blur(10px);
            padding: 1rem 2rem;
            border-radius: 10px;
            display: flex;
            gap: 2rem;
            z-index: 999; 
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 1.8rem;
            font-weight: 700;
            color: #667eea;
        }

        .stat-label {
            font-size: 0.85rem;
            color: #aaa;
            margin-top: 0.2rem;
        }

        /* View Controls */
        .view-controls {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: rgba(42, 42, 42, 0.95);
            backdrop-filter: blur(10px);
            padding: 0.5rem;
            border-radius: 10px;
            display: flex;
            gap: 0.5rem;
            z-index: 1000;
        }

        .view-btn {
            padding: 0.6rem 1rem;
            background: transparent;
            color: white;
            border: 1px solid #444;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .view-btn.active {
            background: #667eea;
            border-color: #667eea;
        }

        .view-btn:hover {
            background: #3a3a3a;
        }

        /* Loading */
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 2000;
            background: rgba(0,0,0,0.8);
            padding: 2rem;
            border-radius: 10px;
        }

        @media (max-width: 768px) {
            .sidebar {
                position: absolute;
                left: -350px;
                z-index: 1001;
                transition: left 0.3s;
            }

            .sidebar.open {
                left: 0;
            }

            .stats-banner {
                flex-direction: column;
                gap: 0.5rem;
                padding: 0.8rem 1rem;
            }
        }
    </style>
</head>
<body>
    <div id="cesiumContainer">
        <div class="cesium-controls">
            <div style="background: rgba(42, 42, 42, 0.9); padding: 15px; border-radius: 10px; color: white; display: flex; flex-direction: column; gap: 10px; border: 1px solid #444; min-width: 250px; backdrop-filter: blur(5px);">
                
                <div style="display: flex; flex-direction: column; gap: 3px;">
                    <label style="font-size: 11px; text-transform: uppercase; color: #aaa;">Altitude du drone</label>
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <input type="range" id="altSlider" min="200" max="3000" value="1200" step="100" oninput="updateAltitude(this.value)" style="flex: 1;">
                        <span style="font-size: 13px; font-weight: bold; min-width: 45px;"><span id="altValue">1200</span>m</span>
                    </div>
                </div>

                <div id="timelineContainer" style="display: none; flex-direction: column; gap: 3px;">
                    <label style="font-size: 11px; text-transform: uppercase; color: #aaa;">Progression du parcours</label>
                    <input type="range" id="flyTimeline" min="0" max="100" value="0" step="0.1" oninput="seekTimeline(this.value)" style="width: 100%; accent-color: #10b981;">
                </div>
                
                <div style="display: flex; gap: 8px; margin-top: 5px;">
                    <button id="flyButton" class="btn-3d" style="flex: 2; background: #667eea;" onclick="startFlyOver()">‚úàÔ∏è Lancer le survol</button>
                    <button id="pauseButton" class="btn-3d" style="flex: 1; background: #f59e0b; display: none;" onclick="togglePause()">‚è∏</button>
                </div>
                
                <button class="btn-3d" style="background:#ef4444;" onclick="close3DView()">‚úñ Quitter la 3D</button>
            </div>
        </div>
    </div>

    <div class="container">
        <!-- Header -->
        <div class="header">
            <h1>üó∫Ô∏è Carte Interactive des Randonn√©es</h1>
            <div class="header-buttons">
                <a href="/years" class="btn btn-secondary">‚Üê Retour</a>
                <button class="btn btn-primary" onclick="uploadGPX()">üì§ Importer GPX</button>
            </div>
        </div>

        <!-- Main Content -->
        <div class="main-content">
            <!-- Sidebar -->
            <div class="sidebar" id="sidebar">
                <!-- Filters -->
                <div class="sidebar-section">
                    <h3>üîç Filtres</h3>
                    <div class="filter-group">
                        <label>Ann√©e</label>
                        <select id="yearFilter" onchange="applyFilters()">
                            <option value="all">Toutes les ann√©es</option>
                            <option value="2026">2026</option>
                            <option value="2025">2025</option>
                            <option value="2024">2024</option>
                            <option value="2023">2023</option>
                            <option value="2022">2022</option>
                            <option value="2021">2021</option>
                            <option value="2020">2020</option>
                            <option value="2019">2019</option>
                            <option value="2018">2018</option>
                            <option value="2017">2017</option>
                            <option value="2016">2016</option>
                            <option value="2015">2015</option>
                            <option value="2014">2014</option>
                            <option value="2013">2013</option>
                            <option value="2012">2012</option>
                            <option value="2011">2011</option>
                            <option value="2010">2010</option>
                            <option value="2009">2009</option>
                            <option value="2008">2008</option>
                        </select>
                    </div>
                    <div class="filter-group">
                        <label>Difficult√©</label>
                        <select id="difficultyFilter" onchange="applyFilters()">
                            <option value="all">Toutes</option>
                            <option value="facile">Facile</option>
                            <option value="moyen">Moyen</option>
                            <option value="difficile">Difficile</option>
                        </select>
                    </div>
                </div>

                <!-- Hikes List -->
                <div class="sidebar-section">
                    <h3>üìç Randonn√©es (<span id="hikeCount">0</span>)</h3>
                    <div id="hikesList"></div>
                </div>
            </div>

            <!-- Map -->
            <div class="map-container">
                <!-- Stats Banner -->
                <div class="stats-banner">
                    <div class="stat-item">
                        <div class="stat-value" id="totalHikes">0</div>
                        <div class="stat-label">Randonn√©es</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="totalPhotos">0</div>
                        <div class="stat-label">Photos</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="totalDistance">0</div>
                        <div class="stat-label">km parcourus</div>
                    </div>
                </div>

                <!-- View Controls -->
                <div class="view-controls">
                    <button class="view-btn active" onclick="setView('markers')" id="markersBtn">üìç Markers</button>
                    <button class="view-btn" onclick="setView('heatmap')" id="heatmapBtn">üî• Heatmap</button>
                    <button class="view-btn" onclick="setView('clusters')" id="clustersBtn">üìä Clusters</button>
                </div>

                <div id="map"></div>
            </div>
        </div>
    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
    <script src="https://unpkg.com/leaflet.heat@0.2.0/dist/leaflet-heat.js"></script>

    <script>

        // AJOUTEZ CETTE LIGNE ICI (tout en haut du script)
        Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiJjNDVmZWQxZS1kOWRiLTRiNGYtOTFiZC00MDE5YTMzOWJmY2IiLCJpZCI6MzgzNTY1LCJpYXQiOjE3Njk0MzQ0ODJ9.GXzgBLufCYZRr5d7EeZ7fEYGQZycxJS709tbps8hCXk';

        // D√©tecter si on est en mode d√©veloppement
        let isDevMode = false;
        {% if dev_mode %}
        isDevMode = true;
        {% endif %}
        
        // Donn√©es des randonn√©es - charg√©es dynamiquement uniquement
        let hikesData = [];
        
        let map;
        let markersLayer;
        let heatmapLayer;
        let clustersLayer;
        let gpxTracksLayer;  // Nouvelle couche pour les traces GPX
        let currentView = 'markers';
        let filteredHikes = [];
        let displayedGPXTracks = new Set();  // Suivre les traces d√©j√† affich√©es

        // Charger les donn√©es dynamiquement selon l'ann√©e
        async function loadHikesData(year = 2026) {
            try {
                console.log(`üîÑ Chargement des donn√©es pour ${year}...`);
                const response = await fetch(`/api/hikes?year=${year}`);
                hikesData = await response.json();
                filteredHikes = hikesData;
                
                console.log(`‚úÖ Chargement optimis√© : ${hikesData.length} randonn√©es pour ${year}`);
                
                // Mettre √† jour le select d'ann√©e
                document.getElementById('yearFilter').value = year.toString();
                
                // Mettre √† jour l'affichage
                updateStats();
                updateHikesList();
                displayMarkers();
                
                // Charger les traces GPX pour cette ann√©e
                loadAllGPXTracks();
                
            } catch (error) {
                console.error('Erreur lors du chargement des donn√©es:', error);
            }
        }

        // Initialiser la carte
        function initMap() {
            // Centre sur les Alpes fran√ßaises
            map = L.map('map').setView([45.2, 5.9], 10);

            // Fond de carte
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap contributors',
                maxZoom: 18
            }).addTo(map);

            // Initialiser les couches
            markersLayer = L.layerGroup().addTo(map);
            heatmapLayer = L.layerGroup();
            clustersLayer = L.markerClusterGroup();
            gpxTracksLayer = L.layerGroup().addTo(map);  // Ajouter la couche GPX
            
            // Charger les donn√©es de 2026 par d√©faut
            loadHikesData(2026);
        }

        // Charger et afficher les randonn√©es
        function loadHikes() {
            // S√©lectionner automatiquement l'ann√©e 2026 SANS d√©clencher onchange
            const yearFilter = document.getElementById('yearFilter');
            yearFilter.value = '2026';
            
            // Appliquer les filtres manuellement pour √©viter le double appel
            const year = yearFilter.value;
            const difficulty = document.getElementById('difficultyFilter').value;
            
            filteredHikes = hikesData.filter(hike => {
                if (year !== 'all' && !hike.date.startsWith(year)) return false;
                if (difficulty !== 'all' && hike.difficulty !== difficulty) return false;
                return true;
            });
            
            updateStats();
            updateHikesList();
            displayMarkers();
            
            // Charger automatiquement les traces GPX existantes (uniquement pour 2026)
            loadAllGPXTracks();
        }

        // Charger toutes les traces GPX disponibles
        async function loadAllGPXTracks() {
            for (const hike of filteredHikes) {  // Utiliser les randonn√©es FILTR√âES, pas toutes
                if (hike.gpx_file && !displayedGPXTracks.has(hike.id)) {
                    await loadGPXTrack(hike.id);
                }
            }
        }

        // Charger une trace GPX sp√©cifique
        async function loadGPXTrack(hikeId) {
            try {
                const response = await fetch(`/api/hike/${hikeId}/gpx/track`);
                const data = await response.json();
                
                if (response.ok && data.segments) {
                    displayGPXTrack(hikeId, data.segments, data.stats);
                    displayedGPXTracks.add(hikeId);
                }
            } catch (error) {
                console.warn(`Impossible de charger la trace GPX pour ${hikeId}:`, error);
            }
        }

        // Afficher une trace GPX sur la carte
        function displayGPXTrack(hikeId, segments, stats) {
            const hike = hikesData.find(h => h.id === hikeId);
            const difficulty = hike?.difficulty || 'moyen';
            
            // Couleurs bas√©es sur la difficult√©
            const colors = {
                'facile': '#10b981',
                'moyen': '#f59e0b', 
                'difficile': '#ef4444'
            };
            
            const trackColor = colors[difficulty] || '#667eea';
            
            // Cr√©er un polyline pour chaque segment
            segments.forEach((segment, index) => {
                const polyline = L.polyline(segment, {
                    color: trackColor,
                    weight: 3,
                    opacity: 0.8,
                    smoothFactor: 1
                });
                
                // Ajouter un popup avec les informations
                const popupContent = `
                    <div style="min-width: 200px;">
                        <h4 style="margin: 0 0 10px 0; color: ${trackColor};">
                            ü•æ ${hike?.name || 'Trace GPX'}
                        </h4>
                        <div style="font-size: 0.9rem;">
                            <div>üìè Distance: ${stats?.total_distance || '?'} km</div>
                            <div>‚õ∞Ô∏è D+: ${stats?.elevation_gain || '?'} m</div>
                            <div>üìç Segments: ${segments.length}</div>
                        </div>
                        <div style="margin-top: 10px;">
                            <button onclick="window.location.href='/gallery/${hikeId}'" 
                                    style="background: ${trackColor}; color: white; border: none; 
                                           padding: 5px 10px; border-radius: 4px; cursor: pointer;">
                                Voir la galerie
                            </button>
                        </div>
                    </div>
                `;
                
                polyline.bindPopup(popupContent);
                polyline.on('mouseover', function() {
                    this.setStyle({ weight: 5, opacity: 1 });
                });
                polyline.on('mouseout', function() {
                    this.setStyle({ weight: 3, opacity: 0.8 });
                });
                
                gpxTracksLayer.addLayer(polyline);
            });
        }

        // Afficher les markers
        // Dans la fonction displayMarkers()
        function displayMarkers() {
            markersLayer.clearLayers();

            filteredHikes.forEach(hike => {
                if (hike.lat && hike.lon) {
                    const marker = L.marker([hike.lat, hike.lon], {
                        icon: createCustomIcon(hike.difficulty)
                    });

                    // Dans la fonction displayMarkers()
                    marker.bindPopup(createPopupContent(hike), {
                        autoPan: true,
                        autoPanPaddingTopLeft: [50, 150], // Augment√© √† 150 pour passer sous la banni√®re
                        autoPanPaddingBottomRight: [50, 20],
                        maxWidth: 350,
                        offset: [0, -10]
                    });
                                    
                    marker.on('click', () => selectHike(hike.id));
                    markersLayer.addLayer(marker);
                }
            });
        }
        
        // Cr√©er une ic√¥ne personnalis√©e
        function createCustomIcon(difficulty) {
            const colors = {
                'facile': '#10b981',
                'moyen': '#f59e0b',
                'difficile': '#ef4444'
            };

            return L.divIcon({
                className: 'custom-marker',
                html: `<div style="
                    background: ${colors[difficulty] || '#667eea'};
                    width: 30px;
                    height: 30px;
                    border-radius: 50% 50% 50% 0;
                    transform: rotate(-45deg);
                    border: 3px solid white;
                    box-shadow: 0 2px 8px rgba(0,0,0,0.3);
                            "></div>`,
                    iconSize: [30, 30],
                    iconAnchor: [15, 30]
                });
            }

        // Cr√©er le contenu du popup
        function createPopupContent(hike) {
            return `
                <div class="popup-content">
                    ${hike.cover_image ? `<img src="${hike.cover_image}" class="popup-image" alt="${hike.name}">` : ''}
                    <h3 class="popup-title">${hike.name}</h3>
                    <p class="popup-description">${hike.description || 'Aucune description'}</p>
                    <div class="popup-stats">
                        <div class="popup-stat">
                            <div class="popup-stat-value">${hike.distance || '?'}</div>
                            <div class="popup-stat-label">km</div>
                        </div>
                        <div class="popup-stat">
                            <div class="popup-stat-value">${hike.denivele || '?'}</div>
                            <div class="popup-stat-label">D+ (m)</div>
                        </div>
                        <div class="popup-stat">
                            <div class="popup-stat-value">${hike.photos_count || 0}</div>
                            <div class="popup-stat-label">Photos</div>
                        </div>
                        <div class="popup-stat">
                            <div class="popup-stat-value">${hike.date}</div>
                            <div class="popup-stat-label">Date</div>
                        </div>
                    </div>
                    <div class="popup-actions">
                        <button class="popup-button" onclick="window.location.href='/gallery/${hike.id}'">
                            Voir la galerie ‚Üí
                        </button>
                        ${hike.gpx_file ? `
                        <button class="popup-button" onclick="open3DView('${hike.id}')" style="margin-bottom: 8px; background: #10b981;">
                            Voir en 3D (Relief)
                        </button>
                        ` : ''}
                    </div>
                </div>
            `;
        }

        function updateStats() {
            document.getElementById('totalHikes').textContent = filteredHikes.length;
            
            const totalPhotos = filteredHikes.reduce((sum, h) => sum + (h.photos_count || 0), 0);
            document.getElementById('totalPhotos').textContent = totalPhotos;
            
            const totalDistance = filteredHikes.reduce((sum, h) => sum + (parseFloat(h.distance) || 0), 0);
            document.getElementById('totalDistance').textContent = totalDistance.toFixed(1);
        }

        // Mettre √† jour la liste des randonn√©es
        function updateHikesList() {
            const list = document.getElementById('hikesList');
            document.getElementById('hikeCount').textContent = filteredHikes.length;
            
            list.innerHTML = filteredHikes.map(hike => `
                <div class="hike-item" onclick="selectHike('${hike.id}')" id="hike-${hike.id}">
                    <div class="hike-header">
                        ${hike.cover_image ? `<img src="${hike.cover_image}" class="hike-image" alt="${hike.name}">` : ''}
                        <div class="hike-info">
                            <div class="hike-name">${hike.name}</div>
                            <div class="hike-stats">
                                <div> ${hike.date}</div>
                                <div> ${hike.photos_count || 0} photos</div>
                                <div> ${hike.distance || '?'} km</div>
                                <div> ${hike.denivele || '?'} m D+</div>
                            </div>
                        </div>
                    </div>
                </div>
            `).join('');
        }

        // S√©lectionner une randonn√©e
        function selectHike(hikeId) {
            // Retirer la classe active
            document.querySelectorAll('.hike-item').forEach(el => el.classList.remove('active'));
            
            // Ajouter la classe active
            const hikeElement = document.getElementById(`hike-${hikeId}`);
            if (hikeElement) hikeElement.classList.add('active');
            
            const hike = filteredHikes.find(h => h.id === hikeId);
                if (hike && hike.lat && hike.lon) {
                    // Trouvez le marqueur correspondant et ouvrez son popup
                    markersLayer.eachLayer(function(marker) {
                        if (marker.getLatLng().lat === hike.lat && marker.getLatLng().lng === hike.lon) {
                            marker.openPopup(); // Leaflet fera le d√©placement (pan) automatiquement et correctement
                        }
                    });
                }
        }

        // Appliquer les filtres
        function applyFilters() {
            const year = document.getElementById('yearFilter').value;
            const difficulty = document.getElementById('difficultyFilter').value;
            
            // Si on change d'ann√©e, recharger les donn√©es
            if (year !== 'all') {
                loadHikesData(parseInt(year));
                return;
            }
            
            // Si "Toutes les ann√©es", charger toutes les donn√©es
            loadHikesData('all');
        }

        // Changer la vue
        function setView(viewType) {
            // Mettre √† jour les boutons
            document.querySelectorAll('.view-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(viewType + 'Btn').classList.add('active');
            
            currentView = viewType;
            
            // Masquer toutes les couches
            map.removeLayer(markersLayer);
            map.removeLayer(heatmapLayer);
            map.removeLayer(clustersLayer);
            
            // Afficher la couche s√©lectionn√©e
            switch(viewType) {
                case 'markers':
                    map.addLayer(markersLayer);
                    break;
                case 'heatmap':
                    createHeatmap();
                    map.addLayer(heatmapLayer);
                    break;
                case 'clusters':
                    createClusters();
                    map.addLayer(clustersLayer);
                    break;
            }
        }

        // Cr√©er la heatmap
        function createHeatmap() {
            heatmapLayer.clearLayers();
            
            const heatData = filteredHikes
                .filter(h => h.lat && h.lon)
                .map(h => [h.lat, h.lon, 0.8]);
            
            L.heatLayer(heatData, {
                radius: 25,
                blur: 15,
                maxZoom: 13,
                gradient: {
                    0.0: 'blue',
                    0.5: 'lime',
                    0.7: 'yellow',
                    1.0: 'red'
                }
            }).addTo(heatmapLayer);
        }

        // Cr√©er les clusters
        function createClusters() {
            clustersLayer.clearLayers();
            
            filteredHikes.forEach(hike => {
                if (hike.lat && hike.lon) {
                    const marker = L.marker([hike.lat, hike.lon], {
                        icon: createCustomIcon(hike.difficulty)
                    });
                    
                    marker.bindPopup(createPopupContent(hike), {
                        autoPan: true,
                        keepInView: true,
                        autoPanPaddingTopLeft: [50, 100],
                        autoPanPaddingBottomRight: [50, 150],
                        autoPanPadding: [50, 100],
                        maxWidth: 350
                    });
                    marker.on('click', () => selectHike(hike.id));
                    
                    clustersLayer.addLayer(marker);
                }
            });
        }

        // Upload GPX
        function uploadGPX() {
            // Cr√©er une fen√™tre modale pour l'upload
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.8);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 3000;
            `;
            
            modal.innerHTML = `
                <div style="background: #2a2a2a; padding: 2rem; border-radius: 10px; max-width: 500px; width: 90%;">
                    <h3 style="margin-bottom: 1.5rem; color: #667eea;">üì§ Importer un fichier GPX</h3>
                    
                    <div style="margin-bottom: 1rem;">
                        <label style="display: block; margin-bottom: 0.5rem; color: #aaa;">S√©lectionner une randonn√©e:</label>
                        <select id="hikeSelect" style="width: 100%; padding: 0.6rem; border-radius: 6px; border: 1px solid #444; background: #1a1a1a; color: white;">
                            <option value="">Choisir une randonn√©e...</option>
                            ${hikesData.map(hike => `<option value="${hike.id}">${hike.name}</option>`).join('')}
                        </select>
                    </div>
                    
                    <div style="margin-bottom: 1.5rem;">
                        <label style="display: block; margin-bottom: 0.5rem; color: #aaa;">Fichier GPX:</label>
                        <input type="file" id="gpxFile" accept=".gpx" style="width: 100%; padding: 0.6rem; border-radius: 6px; border: 1px solid #444; background: #1a1a1a; color: white;">
                        <div style="margin-top: 0.5rem; font-size: 0.8rem; color: #888;">
                            Formats support√©s: .gpx
                        </div>
                    </div>
                    
                    <div id="uploadProgress" style="display: none; margin-bottom: 1rem;">
                        <div style="background: #333; padding: 0.5rem; border-radius: 6px;">
                            <div id="progressBar" style="background: #667eea; height: 4px; border-radius: 2px; width: 0%; transition: width 0.3s;"></div>
                        </div>
                        <div id="progressText" style="margin-top: 0.5rem; color: #aaa; font-size: 0.9rem;">T√©l√©chargement en cours...</div>
                    </div>
                    
                    <div style="display: flex; gap: 1rem; justify-content: flex-end;">
                        <button onclick="closeUploadModal()" style="padding: 0.6rem 1.2rem; background: #666; color: white; border: none; border-radius: 6px; cursor: pointer;">Annuler</button>
                        <button onclick="performUpload()" style="padding: 0.6rem 1.2rem; background: #667eea; color: white; border: none; border-radius: 6px; cursor: pointer;">Importer</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
        }
        
        function closeUploadModal() {
            const modal = document.querySelector('div[style*="position: fixed"]');
            if (modal) {
                modal.remove();
            }
        }
        
        async function performUpload() {
            const hikeSelect = document.getElementById('hikeSelect');
            const gpxFile = document.getElementById('gpxFile');
            
            if (!hikeSelect.value) {
                alert('Veuillez s√©lectionner une randonn√©e');
                return;
            }
            
            if (!gpxFile.files[0]) {
                alert('Veuillez s√©lectionner un fichier GPX');
                return;
            }
            
            const formData = new FormData();
            formData.append('gpx_file', gpxFile.files[0]);
            
            // Afficher la progression
            document.getElementById('uploadProgress').style.display = 'block';
            document.getElementById('progressBar').style.width = '50%';
            document.getElementById('progressText').textContent = 'T√©l√©chargement du fichier...';
            
            try {
                const response = await fetch(`/upload_gpx/${hikeSelect.value}`, {
                    method: 'POST',
                    body: formData
                });
                
                document.getElementById('progressBar').style.width = '80%';
                document.getElementById('progressText').textContent = 'Analyse du GPX...';
                
                const result = await response.json();
                
                if (response.ok) {
                    document.getElementById('progressBar').style.width = '100%';
                    document.getElementById('progressText').textContent = 'Import r√©ussi!';
                    
                    // Afficher les informations import√©es
                    setTimeout(() => {
                        alert(`GPX import√© avec succ√®s!\n\nNom: ${result.gpx_info.name}\nDistance: ${result.gpx_info.distance} km\nD√©nivel√©: ${result.gpx_info.elevation_gain} m\nPoints: ${result.gpx_info.point_count}`);
                        
                        // Recharger les donn√©es et afficher la trace
                        loadGPXTrack(hikeSelect.value);
                        closeUploadModal();
                    }, 1000);
                } else {
                    throw new Error(result.error || 'Erreur lors de l\'upload');
                }
            } catch (error) {
                document.getElementById('progressText').textContent = `Erreur: ${error.message}`;
                document.getElementById('progressBar').style.background = '#ef4444';
                setTimeout(() => {
                    closeUploadModal();
                }, 2000);
            }
        }

        // Recharger les donn√©es d'une randonn√©e sp√©cifique
        async function reloadHikeData(hikeId) {
            try {
                const response = await fetch(`/api/hike/${hikeId}`);
                const hikeData = await response.json();
                
                if (response.ok) {
                    // Mettre √† jour les donn√©es dans hikesData
                    const index = hikesData.findIndex(h => h.id === hikeId);
                    if (index !== -1) {
                        hikesData[index] = hikeData;
                    }
                    
                    // Rafra√Æchir l'affichage
                    applyFilters();
                }
            } catch (error) {
                console.warn('Erreur lors du rechargement des donn√©es:', error);
            }
        }

        
  // --- LOGIQUE CESIUM 3D (CORRIG√âE) ---
        let cesiumViewer = null;
        let currentTrackFor3D = [];
        let isPaused = false;
        let timelineInterval = null;
        let currentAltitude = 1200;
        let currentCameraListener = null; // Variable pour stocker le listener de cam√©ra

        function updateAltitude(val) {
            currentAltitude = parseInt(val);
            document.getElementById('altValue').innerText = val;
        }

        function togglePause() {
            if (!cesiumViewer) return;
            isPaused = !isPaused;
            cesiumViewer.clock.shouldAnimate = !isPaused;
            document.getElementById('pauseButton').innerText = isPaused ? "‚ñ∂Ô∏è" : "‚è∏";
        }

        function seekTimeline(percent) {
            if (!cesiumViewer || !cesiumViewer.clock.startTime) return;
            const totalSeconds = Cesium.JulianDate.secondsDifference(cesiumViewer.clock.stopTime, cesiumViewer.clock.startTime);
            const targetSeconds = (percent / 100) * totalSeconds;
            cesiumViewer.clock.currentTime = Cesium.JulianDate.addSeconds(cesiumViewer.clock.startTime, targetSeconds, new Cesium.JulianDate());
        }

        async function open3DView(hikeId) {
            console.log("D√©marrage vue 3D...");
            document.getElementById('cesiumContainer').style.display = 'block';
            
            if (!cesiumViewer) {
                cesiumViewer = new Cesium.Viewer('cesiumContainer', {
                    terrainProvider: await Cesium.createWorldTerrainAsync(),
                    baseLayerPicker: false,
                    geocoder: false,
                    navigationHelpButton: false,
                    animation: false, 
                    timeline: false
                });
            }

            try {
                const response = await fetch(`/api/hike/${hikeId}/gpx/track`);
                const data = await response.json();
                
                if (data.segments) {
                    currentTrackFor3D = data.segments.flat();
                    cesiumViewer.entities.removeAll();
                    
                    const positions = currentTrackFor3D.map(c => Cesium.Cartesian3.fromDegrees(c[1], c[0]));
                    const entity = cesiumViewer.entities.add({
                        polyline: {
                            positions: positions,
                            width: 5,
                            material: Cesium.Color.YELLOW,
                            clampToGround: true
                        }
                    });
                    
                    // Marqueurs de d√©but et fin supprim√©s pour √©viter qu'ils apparaissent √† travers le terrain
                    
                    // Calculer l'orientation au d√©part de la rando
                    if (currentTrackFor3D.length >= 2) {
                        const startPoint = currentTrackFor3D[0];
                        
                        // Prendre un point plus loin pour avoir une meilleure direction
                        const lookAheadIndex = Math.min(10, currentTrackFor3D.length - 1);
                        const forwardPoint = currentTrackFor3D[lookAheadIndex];
                        
                        // Calculer l'angle de d√©part (bearing) entre le d√©but et le point en avant
                        const lat1 = startPoint[0] * Math.PI / 180;
                        const lon1 = startPoint[1] * Math.PI / 180;
                        const lat2 = forwardPoint[0] * Math.PI / 180;
                        const lon2 = forwardPoint[1] * Math.PI / 180;
                        
                        const dLon = lon2 - lon1;
                        const y = Math.sin(dLon) * Math.cos(lat2);
                        const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);
                        const bearing = Math.atan2(y, x);
                        
                        // Convertir en degr√©s (0-360)
                        const headingDegrees = (bearing * 180 / Math.PI + 360) % 360;
                        
                        // Calculer la distance totale et les bornes de la trace
                        let totalDistance = 0;
                        let minLat = startPoint[0], maxLat = startPoint[0];
                        let minLon = startPoint[1], maxLon = startPoint[1];
                        
                        for (let i = 0; i < currentTrackFor3D.length - 1; i++) {
                            const p1 = currentTrackFor3D[i];
                            const p2 = currentTrackFor3D[i + 1];
                            
                            minLat = Math.min(minLat, p1[0]);
                            maxLat = Math.max(maxLat, p1[0]);
                            minLon = Math.min(minLon, p1[1]);
                            maxLon = Math.max(maxLon, p1[1]);
                            
                            const R = 6371000;
                            const dLat = (p2[0] - p1[0]) * Math.PI / 180;
                            const dLon = (p2[1] - p1[1]) * Math.PI / 180;
                            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                                    Math.cos(p1[0] * Math.PI / 180) * Math.cos(p2[0] * Math.PI / 180) *
                                    Math.sin(dLon/2) * Math.sin(dLon/2);
                            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                            totalDistance += R * c;
                        }
                        
                        // Calculer l'√©tendue de la trace
                        const latSpan = (maxLat - minLat) * 111000; // en m√®tres
                        const lonSpan = (maxLon - minLon) * 111000 * Math.cos(startPoint[0] * Math.PI / 180);
                        const maxSpan = Math.max(latSpan, lonSpan);
                        
                        // Hauteur adapt√©e pour voir toute la trace (entre 2500m et 6000m)
                        const cameraHeight = Math.min(Math.max(maxSpan * 1.3, 2500), 6000);
                        
                        // APPROCHE SIMPLIFI√âE : Positionner la cam√©ra directement au-dessus du point de d√©part
                        // puis la d√©caler l√©g√®rement en arri√®re
                        
                        // La cam√©ra est plac√©e AU POINT DE D√âPART, juste en hauteur
                        const cameraLat = startPoint[0];
                        const cameraLon = startPoint[1];
                        
                        console.log(`Start point [0]: [${startPoint[0].toFixed(6)}, ${startPoint[1].toFixed(6)}]`);
                        console.log(`Forward point [${lookAheadIndex}]: [${forwardPoint[0].toFixed(6)}, ${forwardPoint[1].toFixed(6)}]`);
                        console.log(`Last point: [${currentTrackFor3D[currentTrackFor3D.length-1][0].toFixed(6)}, ${currentTrackFor3D[currentTrackFor3D.length-1][1].toFixed(6)}]`);
                        console.log(`Bearing forward: ${headingDegrees.toFixed(1)}¬∞, Height: ${cameraHeight.toFixed(0)}m`);
                        
                        // Vue de toute la trace avec perspective 3D, orient√©e dans le sens de la marche
                        // La cam√©ra sera positionn√©e de mani√®re √† voir la trace partir du d√©but
                        cesiumViewer.flyTo(entity, {
                            duration: 0,
                            offset: new Cesium.HeadingPitchRange(
                                Cesium.Math.toRadians(headingDegrees), // Orienter dans le sens de la marche
                                Cesium.Math.toRadians(-30), // Angle pour voir le relief en 3D
                                cameraHeight * 1.5 // Distance pour voir toute la trace
                            )
                        });
                        
                        console.log(`Camera positioned: Height=${cameraHeight.toFixed(0)}m, Heading=${headingDegrees.toFixed(1)}¬∞, Distance=${totalDistance.toFixed(0)}m`);
                    } else {
                        // Fallback si moins de 2 points
                        cesiumViewer.zoomTo(entity, new Cesium.HeadingPitchRange(0, Cesium.Math.toRadians(-30), 2500));
                    }
                }
            } catch (e) {
                console.error("Erreur chargement trace:", e);
            }
        } 

 function startFlyOver() {
    if (!currentTrackFor3D.length) return;
    
    const btn = document.getElementById('flyButton');
    const pBtn = document.getElementById('pauseButton');
    const timelineCont = document.getElementById('timelineContainer');
    const timelineInput = document.getElementById('flyTimeline');
    
    // FORCER le nettoyage complet avant de commencer
    if (timelineInterval) {
        clearInterval(timelineInterval);
        timelineInterval = null;
    }
    
    if (currentCameraListener) {
        currentCameraListener();
        currentCameraListener = null;
    }
    
    // Arr√™ter l'horloge si elle tourne
    if (cesiumViewer.clock.shouldAnimate) {
        cesiumViewer.clock.shouldAnimate = false;
    }
    
    btn.disabled = true;
    pBtn.style.display = "block";
    timelineCont.style.display = "flex";
    isPaused = false;
    pBtn.innerText = "‚è∏";

    // 1. Cr√©ation d'une trajectoire liss√©e avec l'altitude ACTUELLE du slider
    const property = new Cesium.SampledPositionProperty();
    const start = Cesium.JulianDate.now();
    const totalDuration = 60; // secondes pour tout le parcours
    
    currentTrackFor3D.forEach((coord, i) => {
        const timeOffset = (i / currentTrackFor3D.length) * totalDuration;
        const time = Cesium.JulianDate.addSeconds(start, timeOffset, new Cesium.JulianDate());
        const position = Cesium.Cartesian3.fromDegrees(coord[1], coord[0], currentAltitude);
        property.addSample(time, position);
    });

    // 2. Configuration de l'horloge
    cesiumViewer.clock.startTime = start.clone();
    cesiumViewer.clock.stopTime = Cesium.JulianDate.addSeconds(start, totalDuration, new Cesium.JulianDate());
    cesiumViewer.clock.currentTime = start.clone();
    cesiumViewer.clock.clockRange = Cesium.ClockRange.LOOP_STOP; // S'arr√™te √† la fin
    cesiumViewer.clock.shouldAnimate = true;

    // 3. Fonction de mise √† jour de la cam√©ra (CORRIG√âE)
    const updateCamera = () => {
        try {
            if (isPaused) return;

            const now = cesiumViewer.clock.currentTime;
            const position = property.getValue(now);
            const lookAheadTime = Cesium.JulianDate.addSeconds(now, 8.0, new Cesium.JulianDate());
            let target = property.getValue(lookAheadTime);

            if (position && target) {
                const direction = Cesium.Cartesian3.normalize(
                    Cesium.Cartesian3.subtract(target, position, new Cesium.Cartesian3()),
                    new Cesium.Cartesian3()
                );

                const backwardOffset = Cesium.Cartesian3.multiplyByScalar(direction, -1500, new Cesium.Cartesian3());
                const heightOffset = new Cesium.Cartesian3(0, 0, 800);
                
                const cameraOffset = Cesium.Cartesian3.add(backwardOffset, heightOffset, new Cesium.Cartesian3());
                const cameraPosition = Cesium.Cartesian3.add(position, cameraOffset, new Cesium.Cartesian3());
                
                const upVector = Cesium.Cartesian3.normalize(cameraPosition, new Cesium.Cartesian3());
                
                const cameraDirection = Cesium.Cartesian3.normalize(
                    Cesium.Cartesian3.subtract(position, cameraPosition, new Cesium.Cartesian3()),
                    new Cesium.Cartesian3()
                );
                
                cesiumViewer.camera.setView({
                    destination: cameraPosition,
                    orientation: {
                        direction: cameraDirection,
                        up: upVector
                    }
                });
            }
        } catch (error) {
            // Erreur silencieuse pour ne pas arr√™ter le vol
        }
    };

    // Attacher le listener de cam√©ra
    currentCameraListener = cesiumViewer.scene.postRender.addEventListener(updateCamera);

    // 4. Fonction de nettoyage
    const cleanup = () => {
        if (timelineInterval) {
            clearInterval(timelineInterval);
            timelineInterval = null;
        }
        
        if (currentCameraListener) {
            currentCameraListener();
            currentCameraListener = null;
        }
        
        cesiumViewer.clock.shouldAnimate = false;
        btn.disabled = false;
        pBtn.style.display = "none";
        timelineCont.style.display = "none";
        isPaused = false;
        pBtn.innerText = "‚è∏";
        timelineInput.value = 0;
    };

    // 5. Gestion de la timeline
    timelineInterval = setInterval(() => {
        if (!isPaused) {
            // V√©rifier si l'horloge tourne encore
            if (!cesiumViewer.clock.shouldAnimate) {
                cesiumViewer.clock.shouldAnimate = true;
            }
            
            const currentSec = Cesium.JulianDate.secondsDifference(
                cesiumViewer.clock.currentTime, 
                cesiumViewer.clock.startTime
            );
            const totalSec = Cesium.JulianDate.secondsDifference(
                cesiumViewer.clock.stopTime, 
                cesiumViewer.clock.startTime
            );
            const progress = (currentSec / totalSec) * 100;
            
            // Mettre √† jour la barre de progression
            timelineInput.value = Math.min(Math.max(progress, 0), 100);
            
            // D√©tecter la fin
            if (progress >= 99.9 && !cesiumViewer.clock.shouldAnimate) {
                cleanup();
                return;
            }
        }
    }, 200);

    // 6. Backup : onStop de l'horloge
    const onStopHandler = () => {
        cleanup();
        cesiumViewer.clock.onStop.removeEventListener(onStopHandler);
    };
    cesiumViewer.clock.onStop.addEventListener(onStopHandler);
}

        function close3DView() {
            document.getElementById('cesiumContainer').style.display = 'none';
            if(cesiumViewer) {
                cesiumViewer.clock.shouldAnimate = false;
                cesiumViewer.trackedEntity = undefined;
            }
            if (timelineInterval) {
                clearInterval(timelineInterval);
                timelineInterval = null;
            }
            if (currentCameraListener) {
                currentCameraListener();
                currentCameraListener = null;
            }
            // R√©activer le bouton au cas o√π
            const btn = document.getElementById('flyButton');
            if (btn) btn.disabled = false;
        }
        
        // Initialiser Leaflet au chargement
        document.addEventListener('DOMContentLoaded', function() {
            initMap();
            
            // Masquer le bouton d'import GPX en production
            if (!isDevMode) {
                const uploadButton = document.querySelector('button[onclick="uploadGPX()"]');
                if (uploadButton) {
                    uploadButton.style.display = 'none';
                }
            }
        });
    </script>
</body>
</html>